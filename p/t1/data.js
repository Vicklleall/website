const DATA={t:'在网页上弹钢琴 - WebAudio API',z:'6281e8610e0e0f71f88de736',u:'2022-05-16',c:'2022-03-08',l:['CC BY 4.0','https://creativecommons.org/licenses/by/4.0/'],h:"<p>演示地址 → <a href='/music/play/'>https://vicklleall.com/music/play/</a></p><p>Web Audio API 提供了在 Web 上控制音频的一个非常有效通用的系统，使用 Web Audio API，我们能在 Web 上实现数字音乐引擎，从而实现在网页上弹钢琴！</p><h4>数字音乐引擎</h4><p>PS：模块化开发是一种良好的习惯，不仅结构清晰，还能为未来扩展更多的功能预留接口。本教程中为了方便讲解，省去了模块结构等，完整的实现请看 Github 仓库 <a href='https://github.com/Vicklleall/midilab-core'>midilab-core</a></p><p>首先定义顶层模块<span class='code-il'>MidiLab</span>，通过<span class='code-il'>new AudioContext()</span>创建WebAudio上下文。后续的音频操作都要基于<span class='code-il'>MidiLab.ctx</span>上下文。</p><div class='code'>const MidiLab = {\n  ctx: new AudioContext()\n};</div><p>接下来创建资源管理模块，定义存放音频缓冲、输出通道、乐器的数组，定义音频资源加载函数。这里我们可以使用 Fetch API 加载音频资源，随后在音频上下文中解码。</p><div class='code'>MidiLab.res = {\n  buffer: [],     // 储存音频缓冲\n  output: [],     // 储存输出通道\n  instrument: [], // 储存乐器\n  // 音频资源加载函数\n  async load(url) {\n    const response = await fetch(url);\n    const audioData = await response.arrayBuffer();\n    const decodedData = await MidiLab.ctx.decodeAudioData(audioData);\n    this.buffer.push(decodedData);\n    return decodedData;\n  }\n};</div><p>WebAudio 的操作是基于音频节点的，例如一个常用的输出过程：原始音频经过声道平衡节点-混响效果节点-音量控制节点，随后输出。单独控制这些节点过于繁琐，因此我们不如把它们包装成一个大节点，内部是这些节点之间的连接和操作，对外只需要有一个输入和输出接口。定义一个基础类，方便后续操作：</p><div class='code'>MidiLab.BaseNode = class {\n  constructor(inputNode, outputNode) {\n    this.inputNode = inputNode;\n    this.outputNode = outputNode || inputNode;\n  }\n  connect(node) {\n    if (node) this.outputNode.connect(node.inputNode);\n  }\n  disconnect(node) {\n    if (node) this.outputNode.disconnect(node.inputNode);\n  }\n};</div><p>利用上面的基础类，创建全局输出节点：经过音量控制节点后输出到最终目标节点。</p><div class='code'>MidiLab.output = new MidiLab.BaseNode(\n  MidiLab.ctx.createGain(), MidiLab.ctx.destination\n);\nMidiLab.output.inputNode.connect(MidiLab.output.outputNode);</div><p>数字音乐引擎通常不止一个输出通道，不同的输出通道可以给加上不同的滤波、混响、压缩等效果，更加灵活。同样利用上面的基础类，我们把输出作为一个大节点，这样对外就只需要输入和输出接口，而内部可以加各种效果。</p><div class='code'>MidiLab.Output = class extends MidiLab.BaseNode {\n  constructor() {\n    super(MidiLab.ctx.createGain());\n    this.connect(MidiLab.output);\n    MidiLab.res.output.push(this);\n  }\n};</div><p>到这里基础的准备工作就完成了，接下来就开始定义音符、组和乐器。</p><h5>音符</h5><p>一个音符需要的属性：</p><li>音源：之前通过<span class='code-il'>MidiLab.res.load()</span>加载的音频缓冲</li><li>根音：音符的原始音高</li><li>起始位置、长度：在音频中的开始位置和持续长度</li><p>如果每个音都有一个音频文件，需要加载的文件数量就太多了，因此我们可以把多个音合在一个音频文件里，通过指定起始位置和长度切分音符。</p><div class='code'>MidiLab.Instrument.Zone = class {\n  constructor(src, root, start = 0, duration = 0) {\n    this.src = src;\n    this.root = root;\n    this.start = start;\n    this.duration = duration || src.duration;\n  }\n};</div><p>这里我们需要定义好音高索引，按照MIDI标准，C-1~G9对应索引为0~127，中央C4为60。为此我们可以定义一个工具函数来实现转换。</p><div class='code'>MidiLab.note = key => {\n  const k = key.slice(0, -1),\n        n = Number(key.slice(-1));\n  let i = {A: 0, B: 2, C: 3, D: 5, E: 7, F: 8, G: 10}[k.slice(-1)];\n  if (k[0] === 'b') {\n    i--;\n  } else if (k[0] === '#') {\n    i++;\n  }\n  return n * 12 + i + 9;\n}</div><p>之后通过<span class='code-il'>MidiLab.note('C4')</span>、<span class='code-il'>MidiLab.note('bB7')</span>、<span class='code-il'>MidiLab.note('#F2')</span>这样就能方便地得到音高索引。</p><h5>组</h5><p>一个乐器可以有多种演奏技巧，所以我们要给乐器的音色分组，然后再将音符添加到组里。</p><div class='code'>MidiLab.Instrument.Group = class extends MidiLab.BaseNode {\n  constructor() {\n    super(MidiLab.ctx.createGain());\n    this.map = [];  // 音符映射表\n    this.on = [];   // 记录正在播放的音符\n    this.release = 0.2;  // 音符释放淡出时长\n    this.enabled = true; // 当前组是否启用\n  }\n};</div><p>将音符添加到组里，指定覆盖的音程范围。</p><div class='code'>addZone(zone, from, to) {\n  for (let i = from; i <= to; i++) this.map[i] = zone;\n}</div><p>接下来实现播放音符函数。定义接口，传入播放的音高索引、播放时机、播放时长。</p><div class='code'>playNote(note, time = 0, duration = 0) { }</div><p>首先创建和连接音频节点。使用<span class='code-il'>MidiLab.ctx.createBufferSource</span>创建用于播放音频的节点，设置其<span class='code-il'>buffer</span>为要播放的音符源。之后连接到<span class='code-il'>MidiLab.ctx.createGain</span>创建的音量节点，用于控制播放音符的音量包络。最后将音量节点连接到组输出。</p><div class='code'>const zone = this.map[note];\nconst src = MidiLab.ctx.createBufferSource();\nconst envelope = MidiLab.ctx.createGain();\nsrc.buffer = zone.src;\nsrc.envelope = envelope;\nsrc.connect(envelope);\nenvelope.connect(this.inputNode);</div><p>十二平均律中，相邻(半)音之间频率倍数为2的1/12次方，通过设置<span class='code-il'>playbackRate</span>调整音符的音高。</p><div class='code'>const tune = note - zone.root + zone.tune;\nif (tune) src.playbackRate.value = 2 ** (tune / 12);</div><p>接下来播放音符。如果没有指定播放时机，则立即播放。如果设置了播放时长，则在指定时间后释放音符。</p><div class='code'>if (!time) time = MidiLab.ctx.currentTime;\nsrc.start(time, zone.start, zone.duration);\nif (duration) {\n  this.releaseNote(src, time + duration);\n} else {\n  this.on[note] = src;\n}</div><p>音符的释放通过<span class='code-il'>setTargetAtTime</span>设置音量的指数衰减。该接口的最后一个参数是<span class='code-il'>timeConstant</span>，设置为释放时间的1/4，则时间到达后会衰减98.2%，足以停止播放了。</p><div class='code'>releaseNote(src, time = 0) {\n  if (!time) time = MidiLab.ctx.currentTime;\n  src.envelope.gain.setTargetAtTime(0, time, this.release / 4);\n  src.stop(time + this.release);\n}</div><h5>乐器</h5><p>最后一步就是创建乐器了（注意乐器代码应当放在音符和组之前）。首先定义好设置输出和创建组的接口。</p><div class='code'>MidiLab.Instrument = class extends MidiLab.BaseNode {\n  constructor(outputId = 0) {\n    super(MidiLab.ctx.createGain());\n    this.setOutput(outputId);\n    this.group = [];\n    MidiLab.res.instrument.push(this);\n  }\n  setOutput(outputId) {\n    const output = MidiLab.res.output[outputId];\n    this.disconnect(this.output);\n    this.connect(output);\n    this.output = output;\n  }\n  createGroup() {\n    const group = new MidiLab.Instrument.Group();\n    group.connect(this);\n    this.group.push(group);\n    return group;\n  }\n};</div><p>之后是音符播放。遍历乐器的所有组，在启用的组上播放音符。</p><div class='code'>playNote(note, time = 0, duration = 0) {\n  for (const group of this.group) {\n    if (group.enabled) group.playNote(note, time, duration);\n  }\n}</div><p>释放音符也是类似，释放所有组正在播放的音符。</p><div class='code'>releaseNote(note, time = 0) {\n  for (const group of this.group) {\n    const src = group.on[note]\n    if (src) {\n      group.releaseNote(src, time);\n      group.on[note] = null;\n    }\n  }\n}</div><p>到这里，基本的音频引擎就搭建完毕了。上面的所有代码已整理到 GitHub 仓库 <a href='https://github.com/Vicklleall/web-piano-demo'>web-piano-demo</a> 的 demo.js 中。接下来我们就可以使用这个音频引擎创建钢琴乐器。</p><h4 id='_skip'>钢琴实例</h4><p>PS：Web Audio API 遵循同源策略，因此你可能需要搭建一个本地服务器来调试，详情参考 <a href='https://github.com/Vicklleall/web-piano-demo/blob/master/README.md'>README.md</a>。</p><p>1. 加载音频文件。这里用到的音频包含了#C4、E4、G4、bB5四个音的采样，每个音持续4秒。</p><div class='code'>const sample = await MidiLab.res.load('sample.wav');</div><p>2. 创建输出、乐器和组。</p><div class='code'>new MidiLab.Output();\nconst Piano = new MidiLab.Instrument();\nconst group = Piano.createGroup();</div><p>3. 创建音符。</p><div class='code'>const C = new MidiLab.Instrument.Zone(sample, MidiLab.note('#C4'), 0, 4);\nconst E = new MidiLab.Instrument.Zone(sample, MidiLab.note('E4'), 4, 4);\nconst G = new MidiLab.Instrument.Zone(sample, MidiLab.note('G4'), 8, 4);\nconst B = new MidiLab.Instrument.Zone(sample, MidiLab.note('bB5'), 12, 4);</div><p>4. 将音符添加到组中。每个音符样本覆盖3个音，4个音符即可覆盖一个八度的12个音，节省采样。</p><div class='code'>group.addZone(C, MidiLab.note('C4'), MidiLab.note('D4'));\ngroup.addZone(E, MidiLab.note('bE4'), MidiLab.note('F4'));\ngroup.addZone(G, MidiLab.note('#F4'), MidiLab.note('#G4'));\ngroup.addZone(B, MidiLab.note('A5'), MidiLab.note('B5'));</div><p>接下来就可以演奏音符了！例如演奏一个C大调一级和弦：</p><div class='code'>Piano.playNote(MidiLab.note('C4'));\nPiano.playNote(MidiLab.note('E4'));\nPiano.playNote(MidiLab.note('G4'));</div><p>尝试一下这段旋律：</p><div class='code'>Piano.playNote(MidiLab.note('#F4'), 0.0, 0.8);\nPiano.playNote(MidiLab.note('G4'), 0.8, 0.4);\nPiano.playNote(MidiLab.note('A5'), 1.2, 0.35);\nPiano.playNote(MidiLab.note('A5'), 1.6, 0.4);\nPiano.playNote(MidiLab.note('G4'), 2.0, 0.4);\nPiano.playNote(MidiLab.note('#F4'), 2.4, 0.4);\nPiano.playNote(MidiLab.note('E4'), 2.8, 0.35);\nPiano.playNote(MidiLab.note('D4'), 3.2, 0.8);\nPiano.playNote(MidiLab.note('E4'), 4.0, 0.4);\nPiano.playNote(MidiLab.note('#F4'), 4.4, 0.35);\nPiano.playNote(MidiLab.note('#F4'), 4.8, 0.6);\nPiano.playNote(MidiLab.note('E4'), 5.4, 0.2);\nPiano.playNote(MidiLab.note('E4'), 5.6, 0.8);</div><p>最后，如果你想进一步实现更复杂的乐器、图形化的界面，可以参考一开始的网页钢琴演示，同样也放到了GitHub仓库里：<a href='https://github.com/Vicklleall/web-piano-demo'>web-piano-demo</a>。</p>"};window.$p();